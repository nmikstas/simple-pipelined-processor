/************************************************************************/
/*  R instruction format:                                               */
/*  op   rd  rs  rt  N/A                                                */
/*  0000_000_000_000_XXX                                                */
/*                                                                      */
/*  I instruction format:                                               */
/*  op    rd  rs  signed_lit                                            */
/*  0000__000_000_000000                                                */
/*                                                                      */
/*  B/S instruction format:                                             */
/*  op    rt  rs  signed_lit                                            */
/*  0000__000_000_000000                                                */
/*                                                                      */
/*  J instruction format:                                               */
/*  op      unsinged_lit                                                */
/*  0000____000000000000                                                */
/*                                                                      */
/*  Opcodes:                                                            */
/*  0000 NOP  N/A                                   (All  zeros)        */
/*  0001 ADD  $rd = $rs + $rt                       (R   format)        */
/*  0010 ADDi $rd = $rs + lit                       (I   format)        */
/*  0011 SUB  $rd = $rs - $rt                       (R   format)        */
/*  0100 SUBi $rd = $rs - lit                       (I   format)        */
/*  0101 LWr  $rd = mem($rs + $rt)                  (R   format)        */
/*  0110 LW   $rd = mem($rs + lit)                  (I   format)        */
/*  0111 SW   mem($rs + lit) = $rt                  (B/S format)        */
/*  1000 JMP  PC = unsigned_lit                     (J   format)        */
/*  1001 BEQ  if $rs == $rt, PC = PC + 2*signed_lit (B/S format)        */
/*                                                                      */
/*  Underscores can be used to separate                                 */
/*  data bits into logical groups.                                      */
/*                                                                      */
/*  C-style comments can be used to make                                */
/*  the code more readable.                                             */
/*                                                                      */
/*  The data radix is base 2(binary).                                   */
/************************************************************************/

//////////////////////////////////////////////////////////////////////////
//  Accumulate all the values in an array.                              //
//                                                                      //
//  Data memory:                                                        //
//  0x00 = Array base address.                                          //
//  0x04 = Array length in elements.                                    //
//  0x0C = Start of array.                                              //
//  0x78 = 7 segment display - memory mapped I/O.                       //
//                                                                      //
//  Registers:                                                          //
//  r0 = Zero reference.                                                //
//  r1 = Array base address.                                            //
//  r2 = Array pointer.                                                 //
//  r3 = Accumulator.                                                   //
//  r4 = Retreived value from memory.                                   //
//////////////////////////////////////////////////////////////////////////

//Address 0
0101_001_000_000_000 //LWr  $r1, $r0($r0) <- Get array start index.
//Address 2
0110__010_000_000100 //LW   $r2, 4($r0)   <- Get array length in words.
//Address 4
0001_010_010_010_000 //ADD  $r2, $r2, $r2 <- *2.
//Address 6
0001_010_010_010_000 //ADD  $r2, $r2, $r2 <- *2, Array length in bytes.
//Address 8
0100__010_010_000100 //SUBi $r2, $r2, 4   <- Subtract 4 to find start of last word.
//Address 10
0011_011_011_011_000 //SUB  $r3, $r3, $r3 <- Zero out accumulator.

//AccumLoop:

//Address 12
0101_100_001_010_000 //LWr  $r4, $r2($r1) <- Get value from array.
//Address 14
0001_011_011_100_000 //ADD  $r3, $r3, $r4 <- Add value to the accumulator.
//Address 16
1001__010_000_000010 //BEQ  $r2, $r0, 2   <- Exit if last index reached.
//Address 18
0100__010_010_000100 //SUBi $r2, $r2, 4   <- Decrement to next array index.
//Address 20
1000____000000001100 //JMP  AccumLoop     <- More work to do, loop.

//LoopFinished:

//Address 22
0010__010_000_011110 //ADDi $r2, $r0, 30  <- Load register with 30.
//Address 24
0001_010_010_010_000 //ADD  $r2, $r2, $r2 <- *2.
//Address 26
0001_010_010_010_000 //ADD  $r2, $r2, $r2 <- *2, Now contains address 120.
//Address 28
0111__011_010_000000 //SW   $r3, 0($r2)   <-Write results to 7 segment display. 

//Spinlock:

//Address 30
1000____000000011110 //JMP  Spinlock      <- Done.
